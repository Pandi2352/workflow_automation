import { ErrorEntity, HttpStatus, LoggerHelper, RequestContext } from "@skillmine-dev/code-utils";
import { OneDriveFileStorageService } from "../../../storage-srv/services/classes/OneDriveFileStorageService";
import { WorkflowService } from "./WorkflowConfigService";
import { DbContext } from "../../../../database/DBContext";

/**
 * OneDrive Trigger Monitor Service
 *
 * This service monitors OneDrive folders for new file uploads and triggers workflows automatically.
 *
 * Features:
 * - Polls OneDrive folders at configurable intervals
 * - Tracks processed files to avoid duplicates
 * - Automatically triggers workflows when new files are detected
 * - Supports multiple folder monitors running concurrently
 *
 * Usage:
 * 1. Start monitoring a folder: startMonitoring()
 * 2. Stop monitoring: stopMonitoring()
 * 3. Get monitoring status: getMonitoringStatus()
 */
export class OneDriveTriggerMonitorService {
    private static _instance: OneDriveTriggerMonitorService;
    private monitors: Map<string, NodeJS.Timeout> = new Map();
    private processedFiles: Map<string, Set<string>> = new Map(); // folder_id -> Set of file_ids

    static get Instance() {
        if (!this._instance) this._instance = new OneDriveTriggerMonitorService();
        return this._instance;
    }

    private constructor() { }

    async checkAndTrigger(
        currentContext: RequestContext,
        config: {
            folder_id: string;
            access_token: string;
            workflow_nodes: any[];
            workflow_edges: any[];
        }
    ) {
        const {
            folder_id,
            access_token,

            workflow_nodes,
            workflow_edges
        } = config;

        const monitor_id = `${folder_id}`;

        // Init processed files set
        if (!this.processedFiles.has(monitor_id)) {
            this.processedFiles.set(monitor_id, new Set());
        }

        const processedSet = this.processedFiles.get(monitor_id)!;

        // Fetch current folder files
        const drive = OneDriveFileStorageService.Instance;
        const fileList = await drive.listOnlyFiles(
            currentContext,
            access_token,
            folder_id
        );

        const newFiles = fileList.files.filter(f => !processedSet.has(f.id));

        if (newFiles.length === 0) {
            return {
                new_files_found: false,
                count: 0,
                message: "No new files",
            };
        }

        LoggerHelper.Instance.info(
            currentContext.x_request_id,
            `Found ${newFiles.length} new file(s) in OneDrive`,
            { folder_id }
        );

        // Mark as processed
        newFiles.forEach(f => processedSet.add(f.id));

        // Trigger workflow ONCE (not per file)
        await WorkflowService.Instance.workflowexecution(currentContext, {
            nodes: workflow_nodes,
            edges: workflow_edges
        });

        return {
            new_files_found: true,
            count: newFiles.length,
            message: `${newFiles.length} new file(s) processed`,
        };
    }

    async startMonitoring(
        currentContext: RequestContext,
        monitorConfig: {
            folder_id: string;
            access_token: string;
            template_id: string;
            polling_interval?: number;

            workflow_nodes: any[];
            workflow_edges: any[];
        }
    ): Promise<{ success: boolean; message: string; monitor_id: string }> {
        try {
            const {
                folder_id,
                access_token,
                template_id,
                polling_interval = 60000, // Default: 1 minute

                workflow_nodes,
                workflow_edges
            } = monitorConfig;

            const monitor_id = `${folder_id}_${template_id}`;

            // Check if already monitoring
            if (this.monitors.has(monitor_id)) {
                return {
                    success: false,
                    message: "Already monitoring this folder for this template",
                    monitor_id
                };
            }

            LoggerHelper.Instance.info(
                currentContext.x_request_id,
                `Starting OneDrive folder monitoring`,
                { folder_id, template_id, polling_interval }
            );

            // Initialize processed files set for this monitor
            if (!this.processedFiles.has(monitor_id)) {
                this.processedFiles.set(monitor_id, new Set());
            }

            // Load existing files to mark as processed (avoid triggering on existing files)
            await this.loadExistingFiles(currentContext, monitor_id, access_token, folder_id);

            // Start polling
            const intervalId = setInterval(async () => {
                try {
                    await this.checkForNewFiles(
                        currentContext,
                        monitor_id,
                        access_token,
                        folder_id,

                        workflow_nodes,
                        workflow_edges
                    );
                } catch (error) {
                    LoggerHelper.Instance.error(
                        currentContext.x_request_id,
                        `Error in OneDrive monitoring loop`,
                        error
                    );
                }
            }, polling_interval);

            this.monitors.set(monitor_id, intervalId);

            return {
                success: true,
                message: `Started monitoring folder ${folder_id}`,
                monitor_id
            };

        } catch (error) {
            LoggerHelper.Instance.error(
                currentContext.x_request_id,
                "Error starting OneDrive monitoring",
                error
            );
            throw error;
        }
    }

    /**
     * Stop monitoring a OneDrive folder
     */
    async stopMonitoring(monitor_id: string): Promise<{ success: boolean; message: string }> {
        const intervalId = this.monitors.get(monitor_id);

        if (!intervalId) {
            return {
                success: false,
                message: "Monitor not found"
            };
        }

        clearInterval(intervalId);
        this.monitors.delete(monitor_id);
        this.processedFiles.delete(monitor_id);

        return {
            success: true,
            message: `Stopped monitoring ${monitor_id}`
        };
    }

    /**
     * Get monitoring status
     */
    getMonitoringStatus(): {
        active_monitors: number;
        monitor_ids: string[];
    } {
        return {
            active_monitors: this.monitors.size,
            monitor_ids: Array.from(this.monitors.keys())
        };
    }

    /**
     * Load existing files to avoid triggering on them
     */
    private async loadExistingFiles(
        currentContext: RequestContext,
        monitor_id: string,
        access_token: string,
        folder_id: string
    ): Promise<void> {
        try {
            const oneDriveService = OneDriveFileStorageService.Instance;
            const filesList = await oneDriveService.listOnlyFiles(
                currentContext,
                access_token,
                folder_id
            );

            const processedSet = this.processedFiles.get(monitor_id);
            if (processedSet) {
                filesList.files.forEach(file => processedSet.add(file.id));
                LoggerHelper.Instance.info(
                    currentContext.x_request_id,
                    `Marked ${filesList.files.length} existing files as processed`,
                    { monitor_id, folder_id }
                );
            }
        } catch (error) {
            LoggerHelper.Instance.error(
                currentContext.x_request_id,
                "Error loading existing files",
                error
            );
        }
    }

    /**
     * Check for new files in the monitored folder
     */
    private async checkForNewFiles(
        currentContext: RequestContext,
        monitor_id: string,
        access_token: string,
        folder_id: string,

        workflow_nodes: any[],
        workflow_edges: any[]
    ): Promise<void> {
        try {
            const oneDriveService = OneDriveFileStorageService.Instance;
            const filesList = await oneDriveService.listOnlyFiles(
                currentContext,
                access_token,
                folder_id
            );

            const processedSet = this.processedFiles.get(monitor_id);
            if (!processedSet) return;

            // Find new files
            const newFiles = filesList.files.filter(file => !processedSet.has(file.id));

            if (newFiles.length > 0) {
                LoggerHelper.Instance.info(
                    currentContext.x_request_id,
                    `Detected ${newFiles.length} new files in OneDrive folder`,
                    { monitor_id, folder_id }
                );

                // Trigger workflow for new files
                await this.triggerWorkflow(
                    currentContext,
                    access_token,
                    folder_id,

                    workflow_nodes,
                    workflow_edges
                );

                // Mark files as processed
                newFiles.forEach(file => processedSet.add(file.id));
            }

        } catch (error) {
            LoggerHelper.Instance.error(
                currentContext.x_request_id,
                "Error checking for new files",
                error
            );
        }
    }

    /**
     * Trigger workflow execution
     */
    private async triggerWorkflow(
        currentContext: RequestContext,
        access_token: string,
        folder_id: string,

        workflow_nodes: any[],
        workflow_edges: any[]
    ): Promise<void> {
        try {
            LoggerHelper.Instance.info(
                currentContext.x_request_id,
                "Triggering workflow from OneDrive monitor",
                { folder_id }
            );

            // Prepare workflow execution data
            const workflowData = {
                nodes: workflow_nodes,
                edges: workflow_edges
            };

            // Execute the workflow
            await WorkflowService.Instance.workflowexecution(currentContext, workflowData);

            LoggerHelper.Instance.info(
                currentContext.x_request_id,
                "Workflow triggered successfully",
                { folder_id }
            );

        } catch (error) {
            LoggerHelper.Instance.error(
                currentContext.x_request_id,
                "Error triggering workflow",
                error
            );
            throw error;
        }
    }

    /**
     * Stop all monitors (cleanup)
     */
    stopAllMonitors(): void {
        this.monitors.forEach((intervalId, monitor_id) => {
            clearInterval(intervalId);
        });
        this.monitors.clear();
        this.processedFiles.clear();
    }
}
