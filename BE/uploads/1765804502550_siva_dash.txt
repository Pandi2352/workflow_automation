import { useEffect, useState } from "react";
import CalendarIcon from "../icons/CalenderIcon";
import UsersIcon from "../icons/UserIcon";
import { BookingEndpoints, ProfileEndpoints } from "../../api/apiEndpoints";
import axiosInstanceMasters from "../../api/api-master";
import Notify from "simple-notify";
import "simple-notify/dist/simple-notify.css";
import PhleboAssignmentOverlay from "../BookingComponents/PhleboAssignment";
import { usePhleboTracking } from "../../hooks/usePhleboTracking";
import PhleboTrackingMap from "../BookingComponents/PhleboTrackingMap";
import PhoneContact from "../BookingComponents/PhoneContact";
import ChatOverlay from "../BookingComponents/chatOverlay";
import CancelBookingModal from "../BookingComponents/CancelBookingModal";
import Chat from "../../../public/chatbot.svg";
import RatingModal from "../BookingComponents/PhleboRatings";
import PhleboRatingDisplay from "../BookingComponents/PhleboRatingsDisplay";
import OTPVerificationModal from "../BookingComponents/OtpVerificationModal";
import { useSocket } from "../../context/SocketContext";

const BookingDetails = ({
  orderId,
  onBack,
  onBookingCancelled,
  bookingType = "upcoming",
}: {
  orderId: string;
  onBack: () => void;
  onBookingCancelled: () => void;
  bookingType?: "upcoming" | "past" | "cancelled";
}) => {
  const [booking, setBooking] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [showModal, setShowModal] = useState(false);
  const [cancelReason, setCancelReason] = useState("");
  const [, setIsMapLoading] = useState(true);
  const [, setIsMapApiLoaded] = useState(true);
  const [isChatOpen, setIsChatOpen] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  const [isRatingModalOpen, setIsRatingModalOpen] = useState(false);

  // Phlebo specific states
  const [phleboData, setPhleboData] = useState<any>(null);
  const [, setPhleboLoading] = useState(false);
  const [isPhleboAssigned, setIsPhleboAssigned] = useState(false);
  const [isWaitingForPhlebo, setIsWaitingForPhlebo] = useState(false);

  // OTP and Sample Collection states
  const [isOTPVerified, setIsOTPVerified] = useState(false);
  const [showOTPModal, setShowOTPModal] = useState(false);
  const [sampleStatus, setSampleStatus] = useState<any>(null);
  const [loadingSampleStatus, setLoadingSampleStatus] = useState(false);
  const [showMap, setShowMap] = useState(true);

  // Closing OTP states
  const [closingOtp, setClosingOtp] = useState("");
  const [closingOtpVerified, setClosingOtpVerified] = useState(false);
  const [closingOtpFetched, setClosingOtpFetched] = useState(false);

  // Use global socket context
  const { getPhleboData, socket } = useSocket();

  // Use the phlebo tracking hook
  const { phleboLocation, routeData } = usePhleboTracking(orderId, phleboData);

  // Fetch sample OTP from QC API
  const fetchSampleOTP = async (visitId: string) => {
    try {
      if (closingOtpFetched) {
        console.log("âš ï¸ Closing OTP already fetched, skipping duplicate call");
        return closingOtp;
      }

      console.log("ðŸ“ž Fetching closing OTP for visit:", visitId);
      const fullUrl = `${import.meta.env.VITE_PUBLIC_API_DOMAIN}${BookingEndpoints.SAMPLE_OTP}/${visitId}`;
      const response = await axiosInstanceMasters.get(fullUrl);
      
      if (response.data?.success && response.data?.data?.otp) {
        console.log("ðŸ“© Sample OTP received from QC API:", response.data.data.otp);
        const otpValue = String(response.data.data.otp);
        setClosingOtp(otpValue);
        setClosingOtpFetched(true);
        
        new Notify({
          status: "success",
          title: "Sample Collection OTP Generated",
          autoclose: true,
          autotimeout: 3000,
        });
        
        return otpValue;
      }
    } catch (error) {
      console.error("âŒ Error fetching sample OTP:", error);
      new Notify({
        status: "error",
        title: "Error",
        text: "Failed to fetch sample OTP. Please try again.",
        autoclose: true,
        autotimeout: 3000,
      });
    }
    return null;
  };

  // Fetch sample collection status
  const fetchSampleStatus = async (visitId: string) => {
    try {
      setLoadingSampleStatus(true);
      console.log("ðŸ”„ Polling sample status for visit:", visitId);
      const fullUrl = `${import.meta.env.VITE_PUBLIC_API_DOMAIN}${BookingEndpoints.SAMPLE_STATUS}/${visitId}`;
      
      const response = await axiosInstanceMasters.get(fullUrl);

      if (response.data?.success) {
        const statusData = response.data.data;
        setSampleStatus(statusData);
        
        console.log("ðŸ“Š Sample Status:", {
          allCollected: statusData.is_all_specimen_collected,
          closingOtpFetched,
          hasClosingOtp: !!closingOtp,
          closingOtpVerified
        });

        if (statusData.is_all_specimen_collected === true && !closingOtpFetched && !closingOtp) {
          console.log("âœ… All samples collected. Fetching closing OTP (ONE TIME)...");
          await fetchSampleOTP(visitId);
        }
      }
    } catch (error) {
      console.error("âŒ Error fetching sample status:", error);
    } finally {
      setLoadingSampleStatus(false);
    }
  };

  // âœ… Listen for socket closing OTP verification event DIRECTLY
  useEffect(() => {
    if (!socket || !phleboData?.visitId) return;

    const handleSocketClosingOTP = (data: any) => {
      console.log("ðŸ”” Socket closing OTP verification received:", data);
      console.log("ðŸ“‹ Current state:", {
        orderId,
        phleboVisitId: phleboData?.visitId,
        dataVisitId: data?.visit_id,
        dataOrderId: data?.orderId,
        closingOtpVerified,
        isMatch: data?.visit_id === phleboData?.visitId
      });

      // Match by visitId
      if (data?.success && data?.visit_id === phleboData?.visitId && !closingOtpVerified) {
        console.log("âœ…âœ…âœ… CLOSING OTP VERIFIED - OPENING RATING MODAL");
        setClosingOtpVerified(true);
        
        new Notify({
          status: "success",
          title: "Sample Collection Completed!",
          text: "Thank you! Please rate your experience.",
          autoclose: true,
          autotimeout: 3000,
        });
        
        // Open rating modal immediately
        setTimeout(() => {
          console.log("ðŸŽ¯ Opening rating modal now");
          setIsRatingModalOpen(true);
        }, 500);
      }
    };

    // Listen to socket event directly
    socket.on("Sample.otp.verified.customer", handleSocketClosingOTP);

    return () => {
      socket.off("Sample.otp.verified.customer", handleSocketClosingOTP);
    };
  }, [socket, phleboData?.visitId, orderId, closingOtpVerified]);

  // âœ… BACKUP: Also listen for custom event (if your SocketContext dispatches it)
  useEffect(() => {
    const handleClosingOTPVerification = (event: any) => {
      console.log("ðŸ“¨ Custom closing OTP event received:", event.detail);
      
      const { success, visitId, orderId: eventOrderId } = event.detail;
      
      const isMatch = 
        (visitId && visitId === phleboData?.visitId) || 
        (eventOrderId && eventOrderId === orderId);
      
      console.log("ðŸ” Custom event matching:", {
        success,
        isMatch,
        willOpenModal: success && isMatch && !closingOtpVerified
      });
      
      if (success && isMatch && !closingOtpVerified) {
        console.log("âœ… Opening rating modal from custom event");
        setClosingOtpVerified(true);
        
        new Notify({
          status: "success",
          title: "Sample Collection Completed!",
          text: "Thank you! Please rate your experience.",
          autoclose: true,
          autotimeout: 3000,
        });
        
        setTimeout(() => {
          setIsRatingModalOpen(true);
        }, 500);
      }
    };

    window.addEventListener("closingOtpVerified", handleClosingOTPVerification);
    return () => window.removeEventListener("closingOtpVerified", handleClosingOTPVerification);
  }, [phleboData?.visitId, orderId, closingOtpVerified]);

  // Listen for opening OTP verification
  useEffect(() => {
    const handleOTPVerification = (event: any) => {
      console.log("ðŸ“¨ Opening OTP verification event received:", event.detail);
      
      const { success } = event.detail;
      
      if (bookingType === "upcoming" && success) {
        console.log("âœ… Opening OTP verified - showing modal");
        setIsOTPVerified(true);
        setShowOTPModal(true);
        
        new Notify({
          status: "success",
          title: "OTP Verified!",
          text: "Sample collection will begin shortly.",
          autoclose: true,
          autotimeout: 3000,
        });
      }
    };

    window.addEventListener("otpVerified", handleOTPVerification);
    return () => window.removeEventListener("otpVerified", handleOTPVerification);
  }, [orderId, bookingType]);

  // Sync with socket context
  useEffect(() => {
    const syncInterval = setInterval(() => {
      if (orderId) {
        const socketPhleboData = getPhleboData(orderId);
        
        if (socketPhleboData?.otpVerified && !isOTPVerified) {
          setIsOTPVerified(true);
        }
      }
    }, 1000);

    return () => clearInterval(syncInterval);
  }, [orderId, getPhleboData, isOTPVerified]);

  // Handle OTP modal navigation
  const handleOTPVerificationNavigate = async () => {
    setShowOTPModal(false);
    setShowMap(false);
    
    if (phleboData?.visitId) {
      await fetchSampleStatus(phleboData.visitId);
    }
  };

  // Handler to close modal and stay on page
  const handleOTPModalClose = () => {
    setShowOTPModal(false);
    setShowMap(false);
    
    if (phleboData?.visitId) {
      fetchSampleStatus(phleboData.visitId);
    }
  };

  // Poll sample status every 5 seconds - STOPS when closing OTP is fetched
  useEffect(() => {
    let interval: any = null;
    
    if (isOTPVerified && phleboData?.visitId && !closingOtpFetched) {
      console.log("ðŸ”„ Starting sample status polling (every 5 seconds)");
      
      fetchSampleStatus(phleboData.visitId);
      
      interval = setInterval(async () => {
        await fetchSampleStatus(phleboData.visitId);
      }, 5000);
    } else if (closingOtpFetched) {
      console.log("âœ… Closing OTP fetched - STOPPING polling");
    }
    
    return () => {
      if (interval) {
        console.log("ðŸ›‘ Clearing polling interval");
        clearInterval(interval);
      }
    };
  }, [isOTPVerified, phleboData?.visitId, closingOtpFetched]);

  // Check if mobile
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth <= 768);
    };

    checkMobile();
    window.addEventListener("resize", checkMobile);
    return () => window.removeEventListener("resize", checkMobile);
  }, []);

  useEffect(() => {
    if (import.meta.env.VITE_GOOGLE_API_KEY) {
      setIsMapApiLoaded(true);
    } else {
      setIsMapApiLoaded(false);
    }
  }, []);

  // Fetch phlebo details
  const fetchPhleboDetails = async (orderIdParam: string) => {
    try {
      setPhleboLoading(true);
      const phleboUrl = `${import.meta.env.VITE_PUBLIC_API_DOMAIN}${BookingEndpoints.FETCH_PHLEBO}/${orderIdParam}`;
      const response = await axiosInstanceMasters.get(phleboUrl);

      if (response.data?.success && response.data?.data?.visits?.length > 0) {
        const phleboInfo = response.data.data.visits[0];

        if (phleboInfo.phlebo_id) {
          const formattedPhleboData = {
            name: phleboInfo.phleboName || "Phlebo Partner",
            phone: phleboInfo.mobile_number || "",
            otp: phleboInfo.otp || "",
            visitId: phleboInfo.visit_id || "",
            profileUrl: phleboInfo.profile_url || "",
            phleboUserId: phleboInfo.phlebo_id || "",
            location: {
              latitude: phleboInfo.last_known_location?.coordinates?.[1] || null,
              longitude: phleboInfo.last_known_location?.coordinates?.[0] || null,
              timestamp: new Date().toISOString(),
            },
          };

          setPhleboData(formattedPhleboData);
          setIsPhleboAssigned(true);
          setIsWaitingForPhlebo(false);
        } else {
          setPhleboData(null);
          setIsPhleboAssigned(false);
          setIsWaitingForPhlebo(true);
        }
      } else {
        setPhleboData(null);
        setIsPhleboAssigned(false);
        setIsWaitingForPhlebo(true);
      }
    } catch (error) {
      console.error("Error fetching phlebo details:", error);
      setPhleboData(null);
      setIsPhleboAssigned(false);
      setIsWaitingForPhlebo(true);
    } finally {
      setPhleboLoading(false);
    }
  };

  // Submit phlebo rating
  const submitPhleboRating = async (ratingData: {rating: number; feedback: string}) => {
    try {
      const payload = {
        phlebo_user_id: phleboData?.phleboUserId,
        visit_id: phleboData?.visitId,
        rating: ratingData.rating,
        feedback: ratingData.feedback,
      };
      const fullUrl = `${import.meta.env.VITE_PUBLIC_API_DOMAIN}${BookingEndpoints.PHLEBO_RATINGS}`;
      const response = await axiosInstanceMasters.post(fullUrl, payload);

      if (response.data) {
        new Notify({
          status: "success",
          title: "Success!",
          text: "Rating submitted successfully.",
          autoclose: true,
          autotimeout: 3000,
        });
        return true;
      }
    } catch (error) {
      console.error("Error submitting rating:", error);
      new Notify({
        status: "error",
        title: "Error",
        text: "Failed to submit rating. Please try again.",
        autoclose: true,
        autotimeout: 3000,
      });
      return false;
    }
    return false;
  };

  // Fetch booking details
  useEffect(() => {
    const fetchBookingDetails = async () => {
      try {
        setLoading(true);
        const fullUrl = `${import.meta.env.VITE_PUBLIC_API_DOMAIN}${ProfileEndpoints.BOOKING_DETAILS}/${orderId}`;
        const res = await axiosInstanceMasters.get(fullUrl);
        setBooking(res.data?.data);

        if (bookingType === "upcoming" || bookingType === "past" || bookingType === "cancelled") {
          await fetchPhleboDetails(orderId);
        }
      } catch (error) {
        console.error("Error fetching booking details:", error);
      } finally {
        setLoading(false);
      }
    };

    if (orderId) {
      fetchBookingDetails();
    }
  }, [orderId, bookingType]);

  const handleCancelBooking = () => setShowModal(true);
  const handleCloseModal = () => setShowModal(false);
  const handleOpenChat = () => setIsChatOpen(true);
  const handleCloseChat = () => setIsChatOpen(false);

  const handleConfirmCancellation = async () => {
    try {
      const fullUrl = `${import.meta.env.VITE_PUBLIC_API_DOMAIN}/api/v2/booking/utils/re-schedule/${orderId}`;
      const clientId = booking?.client_id;
      const payload = {
        status: "CANCELLED",
        remarks: cancelReason || "No remarks provided",
        client_id: clientId,
      };

      await axiosInstanceMasters.put(fullUrl, payload);

      new Notify({
        status: "success",
        title: "Success!",
        text: "Booking cancelled successfully.",
        autoclose: true,
        autotimeout: 3000,
      });

      setShowModal(false);

      const refreshUrl = `${import.meta.env.VITE_PUBLIC_API_DOMAIN}${ProfileEndpoints.BOOKING_DETAILS}/${orderId}`;
      const res = await axiosInstanceMasters.get(refreshUrl);
      setBooking(res.data?.data);

      if (onBookingCancelled) {
        onBookingCancelled();
      }
    } catch (error) {
      new Notify({
        status: "error",
        title: "Error",
        text: "Failed to cancel booking. Please try again.",
        autoclose: true,
        autotimeout: 3000,
      });
    }
  };

  // Helper function to get patient sample status
  const getPatientSampleStatus = (patientId: string) => {
    if (!sampleStatus?.visit_specimen_details) return null;
    
    return sampleStatus.visit_specimen_details.find(
      (detail: any) => detail.patient_id === patientId
    );
  };

  if (loading) {
    return (
      <div className="p-4 min-h-screen font-outfit">
        <div className="flex items-center mb-6">
          <h1 className="text-xl font-bold">Loading Booking Details...</h1>
        </div>
        <div className="flex justify-center items-center h-64">
          <div className="h-12 w-12 border-4 border-purple-800 border-t-transparent rounded-full animate-spin"></div>
        </div>
      </div>
    );
  }
  
  if (!booking) {
    return <p className="p-4">No booking details found.</p>;
  }

  const { order_id, booked_by_details, address_details, amount, items } = booking;
  const bookedBy = booked_by_details?.given_name || "Unknown";
  const address = address_details
    ? `${address_details.street}, ${address_details.city_name} - ${address_details.pincode}`
    : "No address available";
  const totalCharges = amount || 0;

  // Build patients array with patient IDs
  const patients = Array.isArray(items)
    ? items.flatMap((item: any) =>
        Array.isArray(item.patient_details)
          ? item.patient_details.map((patient: any) => ({
              id: patient.patient_id || patient.id,
              name:
                [patient.given_name, patient.middle_name, patient.family_name]
                  .filter(Boolean)
                  .join(" ") || "Unnamed",
              tests: item.service ? [item.service.name] : [],
            }))
          : []
      )
    : [];

  const userLocation = {
    lat: address_details?.location?.coordinates?.[1] || 23.0225,
    lng: address_details?.location?.coordinates?.[0] || 72.5714,
  };

  return (
    <div className="p-4 min-h-screen font-outfit">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center">
          <button onClick={onBack} className="text-black hover:text-gray-700">
            <svg
              className="w-6 h-6"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              viewBox="0 0 24 24"
            >
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" />
            </svg>
          </button>
          <h1 className="text-xl font-bold ml-2">Booking Details</h1>
        </div>
      </div>

      <div
        className={`flex ${
          bookingType === "upcoming" ? "flex-col lg:flex-row" : "flex-col"
        } gap-12`}
      >
        {/* Map Section */}
        {bookingType === "upcoming" && showMap && !isOTPVerified && (
          <div className="relative w-full max-w-[400px] min-h-[242px] h-full rounded-lg overflow-hidden flex-shrink-0">
            <PhleboTrackingMap
              userLocation={userLocation}
              phleboLocation={phleboLocation}
              routeData={routeData}
              onMapReady={() => setIsMapLoading(false)}
              mapContainerStyle={{ width: "100%", height: "400px" }}
            />

            {isWaitingForPhlebo && !isPhleboAssigned && <PhleboAssignmentOverlay />}

            {/* Opening OTP Card */}
            {isPhleboAssigned && phleboData && !isOTPVerified && (
              <div className="mt-4 w-full max-w-[400px] rounded-lg border border-gray-200 shadow-md overflow-hidden font-outfit">
                <div className="flex items-center p-4 bg-gradient-to-r from-[#17396D] to-[#2C97D3C7] text-white">
                  <img
                    src={phleboData.profileUrl || "https://randomuser.me/api/portraits/men/32.jpg"}
                    alt="Phlebo"
                    className="w-12 h-12 rounded-full mr-3"
                    onError={(e) => {
                      (e.target as HTMLImageElement).src =
                        "https://randomuser.me/api/portraits/men/32.jpg";
                    }}
                  />
                  <div className="flex-1">
                    <h3 className="font-semibold">{phleboData.name || "Phlebo Partner"}</h3>
                    <p className="text-sm">Phlebo partner</p>
                  </div>

                  <button
                    onClick={handleOpenChat}
                    className="ml-2 p-2 bg-white bg-opacity-20 text-white rounded-full hover:bg-opacity-30 transition-colors"
                    title="Chat with Phlebo"
                  >
                    <img src={Chat} alt="chat icon" />
                  </button>
                </div>
                <div className="mt-2">
                  <div className="flex justify-between items-center p-4">
                    <div>
                      <p className="text-xs text-gray-500">Opening OTP</p>
                      <p className="text-2xl font-bold text-[#6A3387]">
                        {phleboData.otp || "----"}
                      </p>
                    </div>
                    {phleboData.phone && <PhoneContact phone={phleboData.phone} isMobile={isMobile} />}
                  </div>
                </div>

                <div className="border-t px-4 py-3 text-center bg-gray-50">
                  <p className="font-semibold text-black">Share the OTP with Phlebo Partner</p>
                  <p className="text-sm text-gray-500">Once phlebo reached your location</p>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Phlebo Card with Closing OTP - Show after opening OTP verified */}
        {bookingType === "upcoming" && isOTPVerified && !closingOtpVerified && (
          <div className="w-full max-w-[400px]">
            <div className="rounded-lg border border-gray-200 shadow-md overflow-hidden font-outfit">
              <div className="flex items-center p-4 bg-gradient-to-r from-[#17396D] to-[#2C97D3C7] text-white">
                <img
                  src={phleboData?.profileUrl || "https://randomuser.me/api/portraits/men/32.jpg"}
                  alt="Phlebo"
                  className="w-12 h-12 rounded-full mr-3"
                  onError={(e) => {
                    (e.target as HTMLImageElement).src =
                      "https://randomuser.me/api/portraits/men/32.jpg";
                  }}
                />
                <div className="flex-1">
                  <h3 className="font-semibold">{phleboData?.name || "Phlebo Partner"}</h3>
                  <p className="text-sm">Phlebo partner</p>
                </div>

                <button
                  onClick={handleOpenChat}
                  className="ml-2 p-2 bg-white bg-opacity-20 text-white rounded-full hover:bg-opacity-30 transition-colors"
                  title="Chat with Phlebo"
                >
                  <img src={Chat} alt="chat icon" />
                </button>
              </div>

              {/* Closing OTP Section */}
              <div className="mt-2">
                <div className="flex justify-between items-center p-4">
                  <div>
                    <p className="text-xs text-gray-500">Sample Collection OTP</p>
                    {closingOtp ? (
                      <p className="text-2xl font-bold text-[#6A3387]">{closingOtp}</p>
                    ) : (
                      <div className="flex items-center gap-2">
                        <div className="h-6 w-6 border-3 border-purple-600 border-t-transparent rounded-full animate-spin"></div>
                        <p className="text-sm text-gray-600">Waiting for samples...</p>
                      </div>
                    )}
                  </div>
                  {phleboData?.phone && <PhoneContact phone={phleboData.phone} isMobile={isMobile} />}
                </div>
              </div>

              <div className="border-t px-4 py-3 text-center bg-gray-50">
                <p className="font-semibold text-black">
                  {closingOtp ? "Share Collection OTP with Phlebo" : "Sample collection in progress"}
                </p>
                <p className="text-sm text-gray-500">
                  {closingOtp
                    ? "Share this OTP after all samples are collected"
                    : "OTP will appear once collection is complete"}
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Past/Cancelled Phlebo Display & Main Booking Details */}
        <div className="flex-1">
          <div className="flex flex-col md:flex-row gap-6 w-full">
            {/* Phlebo card for Past/Cancelled bookings */}
            {(bookingType === "past" || bookingType === "cancelled") &&
              isPhleboAssigned &&
              phleboData && (
                <div className="w-full md:max-w-[350px] rounded-lg overflow-hidden font-outfit self-start">
                  <div className="flex items-center p-4 bg-gradient-to-r from-[#2C97D3] to-[#4B73B9] text-white">
                    <img
                      src={phleboData.profileUrl || "https://randomuser.me/api/portraits/men/32.jpg"}
                      alt="Phlebo"
                      className="w-12 h-12 rounded-full mr-3"
                      onError={(e) => {
                        (e.target as HTMLImageElement).src =
                          "https://randomuser.me/api/portraits/men/32.jpg";
                      }}
                    />
                    <div className="flex-1">
                      <h3 className="font-semibold">{phleboData.name || "Phlebo Partner"}</h3>
                      <p className="text-sm">Phlebo partner</p>
                    </div>

                    {bookingType === "past" && (
                      <PhleboRatingDisplay
                        visitId={phleboData.visitId}
                        phleboUserId={phleboData.phleboUserId}
                      />
                    )}
                  </div>
                </div>
              )}

            {/* Booking Details Card */}
            <div className="flex-1 rounded-lg">
              <div className="flex flex-wrap justify-between space-y-2 items-center text-sm text-white bg-[linear-gradient(78deg,#2C97D3C7,#17396D)] p-3 rounded-lg font-medium">
                <span className="flex items-center gap-2">
                  <CalendarIcon width={17} height={17} fill="white" />
                  Booked By - {bookedBy}
                </span>

                <span className="flex items-center gap-2">
                  <UsersIcon width={17} height={17} fill="white" />
                  No of Patients - {patients.length}
                </span>
              </div>

              <div className="py-6 max-w-[753px] w-full space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 text-sm text-gray-800">
                  <div>
                    <p className="text-[#333333]">Order ID</p>
                    <p className="font-semibold text-black">{order_id}</p>
                  </div>
                  <div>
                    <p className="text-[#333333]">Total Charges</p>
                    <p className="font-semibold text-black">â‚¹{totalCharges}</p>
                  </div>
                  <div>
                    <p className="text-[#333333]">Collection Address</p>
                    <p className="font-semibold text-black">{address}</p>
                  </div>
                </div>

                <hr className="border-gray-50" />

                {/* Patient Test Cards with Sample Collection Status */}
                <div className="space-y-4 bg-[#F6F6F6] rounded-lg p-4">
                  {patients.map((item: any, index: number) => {
                    const patientStatus = getPatientSampleStatus(item.id);
                    const isSampleCollected = patientStatus?.is_sample_collected || false;

                    return (
                      <div
                        key={index}
                        className={`${
                          index !== 0 ? "pt-4 border-t border-gray-200" : ""
                        } flex items-start justify-between`}
                      >
                        <div className="flex-1">
                          <p className="font-semibold text-sm mb-1 text-gray-800">
                            Tests for <span className="text-[#6A3387]">{item.name || "Unnamed"}</span>
                          </p>
                          <p className="text-sm text-gray-600">
                            {item.tests?.join(" | ") || "No tests listed"}
                          </p>
                        </div>
                        
                        {/* Sample Collection Status Badge - Only show when OTP verified */}
                        {isOTPVerified && bookingType === "upcoming" && (
                          <div className="ml-4">
                            {loadingSampleStatus ? (
                              <span className="inline-flex items-center gap-1 px-3 py-1 bg-gray-100 text-gray-600 rounded-full text-xs font-medium">
                                <div className="h-3 w-3 border-2 border-gray-400 border-t-transparent rounded-full animate-spin"></div>
                                Loading...
                              </span>
                            ) : isSampleCollected ? (
                              <span className="inline-flex items-center gap-1 px-3 py-1 bg-green-50 text-green-600 rounded-full text-xs font-medium">
                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                </svg>
                                Sample Collected
                              </span>
                            ) : (
                              <span className="inline-flex items-center gap-1 px-3 py-1 bg-yellow-50 text-yellow-600 rounded-full text-xs font-medium">
                                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
                                </svg>
                                Pending
                              </span>
                            )}
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>

              {bookingType === "upcoming" && !closingOtpVerified && (
                <div className="mt-auto py-6 pt-2">
                  <button
                    className="bg-[#FB3748] hover:bg-red-600 text-white px-[68px] py-[14px] rounded-md text-sm font-medium"
                    onClick={handleCancelBooking}
                  >
                    Cancel Booking
                  </button>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Modals and Overlays */}
      {isPhleboAssigned && phleboData && (
        <ChatOverlay
          isOpen={isChatOpen}
          onClose={handleCloseChat}
          phleboName={phleboData.name}
        />
      )}

      <OTPVerificationModal
        isOpen={showOTPModal}
        onClose={handleOTPModalClose}
        onNavigate={handleOTPVerificationNavigate}
      />

      {bookingType === "upcoming" && (
        <CancelBookingModal
          isOpen={showModal}
          onClose={handleCloseModal}
          onCancel={handleConfirmCancellation}
          cancelReason={cancelReason}
          setCancelReason={setCancelReason}
        />
      )}

      {isPhleboAssigned && phleboData && (
        <RatingModal
          isOpen={isRatingModalOpen}
          onClose={() => setIsRatingModalOpen(false)}
          onSubmit={async (ratingData) => {
            const success = await submitPhleboRating(ratingData);
            if (success) {
              setIsRatingModalOpen(false);
            }
          }}
        />
      )}
    </div>
  );
};

export default BookingDetails;